# 複数スイッチ対応版 ラーニングスイッチの説明

このプログラムは，複数のスイッチに新たな端末が接続されてパケットが飛んできたときに，通信経路を学習しFDB(Forwarding DataBase)に記録して，フローテーブルの通信を制御するプログラムである．

## ラーニングスイッチの説明
ラーニングスイッチの説明を，新たな端末が接続されるところから説明する．

- まず新たな端末Aがスイッチのポート1に接続されるとき

端末Aから端末B宛のパケットが届く．
しかしフローテーブルに登録されていない経路のパケットであるため処理ができず，コントローラにpacket_inする．そのパケットをもとに，コントローラは「ポート1には端末A(MACアドレス)が接続されているのだ」という情報をFDBに登録する．
その後，コントローラはfloodを行い，全ポートに端末Aからのパケットを拡散するが，端末A以外に端末がない．

- 次にさらに新たな端末Bがスイッチのポート2に接続され場合．

端末Bから端末A宛のパケットが届く．
すると再びスイッチはフローテーブルに登録されていない経路のパケットであるためコントローラにpacket_inする．そのパケットをもとに，コントローラは「ポート2には端末B(のMACアドレス)が接続されているのだ」ということを学習する．
そして，端末A宛のパケットを持っていることがわかるが，コントローラは宛先を知っているので，floodをするとともにpacket_outをする．packet_outによってスイッチのフローテーブルには「端末Bから端末Aへの通信はポート2からポート1なのである」ということが記録されるので，次回以降は端末Bから端末Aへのパケットはコントローラを経由しない．

- 次に端末Aが端末B宛のパケットを改めて送信した場合

まだスイッチのフローテーブルには端末Aから端末Bへの通信経路は記録されていないので，再びコントローラに届く．コントローラのFDBには相手の端末Bの情報が登録されているので，floodをしたあとにpacket_outを行い，フローテーブルに「端末Aから端末Bの通信はポート１からポート２なのである」という情報が記録される．

- これ以降は端末A,B間の通信はコントローラを経由しないこととなる

## 複数のスイッチに対応するために
multi_learning_switch.rbでは，その名の通り，複数のスイッチに対応できる．
といっても配列@fdbsを宣言し，その中に以前の@fdbに格納されていた，FDBを複数格納することとなる．
そして今まではスイッチの変数の中からポート番号などを見つけるときにはlookupメソッドを用いていたが，今後はその前にスイッチのdatapathを用いてfetchによってスイッチのFDBを選択する必要がある．

## 各メソッドの説明
単一スイッチのためのプログラムと同じであるが，メソッドを説明する．

- start
tremaプログラム起動時に働き，@fdbsをからの配列としている．以前はこの時点でスイッチとして初期化をしていた．

- switch_ready
スイッチが用意されたら，スイッチごとに駆動する．@fdbs[ID]それぞれにFDBを初期化する．

- packet_in
もし宛先のMACアドレスが既知のものでなければ，入ってきたスイッチのFDBにこのパケットの送信者を学習させ，メッセージをフラッディングさせるとともに，packet_outする．(flow_mod_and_packet_out)を呼ぶ

- age_fdbs
ageをFDBに記録する．

- flow_mod_and_packet_out
パケットをフラッディングさせるとともにpacket_outする

- flow_mod
フラッディングさせる．

- packet_out
パケットの通信経路をフローテーブルに記録する．

